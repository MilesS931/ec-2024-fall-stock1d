
# linear_genotype.py

import random
import ast
from copy import deepcopy

class LinearGenotype():
    def __init__(self):
        self.fitness = None
        self.genes = None
        self.base_fitness = 0
        self.violations = 0
        self.length = 0
        self.width = 0
        self.level = 0


    def random_initialization(self, shapes, bounds, **kwargs):
        # TODO: Initialize self.genes, using the input parameters.
        #       It should be an indexable data structure of length len(shapes),
        #       where each element is an indexable data structure of length 3.
        #       The first value of each element should be an integer within the
        #       half-open interval [bounds[0][0], bounds[0][1]). The second should be
        #       similar, within [bounds[1][0], bounds[1][1]). The third should be
        #       either 0, 1, 2, or 3. All values should be chosen uniform randomly.
        
        # I had help from copilot to give me an idea of how to write this.
        # Initializes the gene variable with a list of lists, each inner list contains three values 
        self.shapes = shapes
        self.bounds = bounds
        self.genes = []
        for _ in range(len(self.shapes)):
            gene = [
                random.randint(self.bounds[0][0], self.bounds[0][1] - 1),
                random.randint(self.bounds[1][0], self.bounds[1][1] - 1),
                random.randint(0, 3)
            ]
            self.genes.append(gene)
        pass


    def serialize(self):
        # TODO: Return a string representation of self.genes
        return str(self.genes)
        pass


    def deserialize(self, serialization):
        # TODO: Recreate self.genes from serialization,
        #       which is a string generated by your serialize method
        self.genes = ast.literal_eval(serialization)
        pass


    def recombine(self, mate, method, **kwargs):
        child = LinearGenotype()

        # TODO: Recombine genes of self with mate and
        #       assign to child's genes member variable
        assert method.casefold() in {'uniform', 'one-point', 'bonus'}
        if method.casefold() == 'uniform':
            # Perform uniform recombination
            child.genes = [
            self.genes[i] if random.random() < 0.5 else mate.genes[i]
            for i in range(len(self.genes))
        ]
            pass

        elif method.casefold() == 'one-point':
            # Perform one-point crossover
            crossover_point = random.randint(1, len(self.genes) - 1)
            child.genes = self.genes[:crossover_point] + mate.genes[crossover_point:]
            pass

        elif method.casefold() == 'bonus':
            # This is a red deliverable (i.e., bonus for anyone).
            # Implement the bonus crossover operator as described
            # in deliverable Red 1 of Assignment 1b.
            pass

        return child


    def mutate(self, bounds, bonus=None, **kwargs):
        mutant = deepcopy(self)

        if not bonus:
            # TODO: Mutate genes of mutant
            # Mutate genes of mutant
            for gene in mutant.genes:
                gene[0] += random.randint(-1, 1)
                gene[1] += random.randint(-1, 1)
                gene[2] = (gene[2] + random.randint(-1, 1)) % 4
                
                gene[0] = max(bounds[0][0], min(gene[0], bounds[0][1] - 1))
                gene[1] = max(bounds[1][0], min(gene[1], bounds[1][1] - 1))
            pass


        else:
            # This is a red deliverable (i.e., bonus for anyone).
            # Implement the bonus mutation operator as described
            # in deliverable Red 1 of Assignment 1b.
            pass

        return mutant


    @classmethod
    def initialization(cls, mu, *args, **kwargs):
        population = [cls() for _ in range(mu)]
        for i in range(len(population)):
            population[i].random_initialization(*args, **kwargs)
        return population
